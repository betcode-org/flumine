{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"fl\u016bmine  <p>flumine is an open-source, event-based trading framework for sports betting, designed to simplify the development and execution of betting strategies on betting exchanges. flumine provides efficient handling of data streams, risk management, and execution capabilities.</p> <p>join betcode slack group (2k+ members!)</p> <p>Tested on Python 3.9, 3.10, 3.11 and 3.12.</p>"},{"location":"#installation","title":"installation","text":"<pre><code>$ pip install flumine\n</code></pre> <p>flumine requires Python 3.9+</p>"},{"location":"#setup","title":"setup","text":"<p>Get started...</p> <pre><code>import betfairlightweight\nfrom flumine import Flumine, clients\n\ntrading = betfairlightweight.APIClient(\"username\")\nclient = clients.BetfairClient(trading)\n\nframework = Flumine(\n    client=client,\n)\n</code></pre> <p>Example strategy:</p> <pre><code>from flumine import BaseStrategy\nfrom flumine.order.trade import Trade\nfrom flumine.order.order import LimitOrder, OrderStatus\nfrom flumine.markets.market import Market\nfrom betfairlightweight.filters import streaming_market_filter\nfrom betfairlightweight.resources import MarketBook\n\n\nclass ExampleStrategy(BaseStrategy):\n    def start(self, flumine) -&gt; None:\n        print(\"starting strategy 'ExampleStrategy'\")\n\n    def check_market_book(self, market: Market, market_book: MarketBook) -&gt; bool:\n        # process_market_book only executed if this returns True\n        if market_book.status != \"CLOSED\":\n            return True\n\n    def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:\n        # process marketBook object\n        for runner in market_book.runners:\n            if runner.status == \"ACTIVE\" and runner.last_price_traded &lt; 1.5:\n                trade = Trade(\n                    market_id=market_book.market_id,\n                    selection_id=runner.selection_id,\n                    handicap=runner.handicap,\n                    strategy=self,\n                )\n                order = trade.create_order(\n                    side=\"LAY\", order_type=LimitOrder(price=1.01, size=2.00)\n                )\n                market.place_order(order)\n\n    def process_orders(self, market: Market, orders: list) -&gt; None:\n        for order in orders:\n            if order.status == OrderStatus.EXECUTABLE:\n                if order.size_remaining == 2.00:\n                    market.cancel_order(order, 0.02)  # reduce size to 1.98\n                if order.order_type.persistence_type == \"LAPSE\":\n                    market.update_order(order, \"PERSIST\")\n                if order.size_remaining &gt; 0:\n                    market.replace_order(order, 1.02)  # move\n\n\n# Add your strategy to the framework\nframework.add_strategy(\n    ExampleStrategy(\n        market_filter=streaming_market_filter(\n            event_type_ids=[\"7\"],\n            country_codes=[\"GB\"],\n            market_types=[\"WIN\"],\n        )\n    )\n)\n\n# Start the trading framework\nframework.run()\n</code></pre> <p>Danger</p> <p>By default flumine will try to prevent coding errors which result in flash crashes and burnt fingers but use at your own risk as per the MIT license.</p> <p>Recommendation is not to remove the trading controls and carry out extensive testing before executing on live markets, even then only use new strategies on an account with a small balance (transfer balance to games wallet).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Streaming</li> <li>Multiple strategies</li> <li>Order execution</li> <li>Paper trading</li> <li>Simulation</li> <li>Event simulation (multi market)</li> <li>Middleware and background workers to enable Scores / RaceCard / InPlayService</li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<p>flumine relies on these libraries:</p> <ul> <li><code>betfairlightweight</code> - Betfair API support</li> <li><code>betdaq-retail</code> - BETDAQ API support</li> <li><code>betconnect</code> - BetConnect API support</li> <li><code>tenacity</code> - Used for connection retrying (streaming)</li> <li><code>python-json-logger</code> - JSON logging</li> <li><code>requests</code> - HTTP support</li> </ul>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#flumine","title":"Flumine","text":"<p>Functions:</p> <ul> <li><code>add_client</code> Adds a client to the framework</li> <li><code>add_strategy</code> Adds a strategy to the framework</li> <li><code>add_worker</code> Adds a worker to the framework</li> <li><code>add_client_control</code> Adds a client control to the framework</li> <li><code>add_trading_control</code> Adds a trading control to the framework</li> <li><code>add_market_middleware</code> Adds market middleware to the framework</li> <li><code>add_logging_control</code> Adds a logging control to the framework</li> </ul> <p>The Flumine class can be adapted by overriding the following functions:</p> <ul> <li><code>_process_market_books()</code> called on MarketBook event</li> <li><code>_process_sports_data()</code> called on SportsData event</li> <li><code>_process_market_orders()</code> called when market has pending orders</li> <li><code>_process_order_package()</code> called on new OrderPackage</li> <li><code>_add_market()</code> called when new Market received through streams</li> <li><code>_remove_market()</code> called when Market removed from framework</li> <li><code>_process_raw_data()</code> called on RawData event</li> <li><code>_process_market_catalogues</code> called on MarketCatalogue event</li> <li><code>_process_current_orders</code> called on currentOrders event</li> <li><code>_process_custom_event</code> called on CustomEvent event see here</li> <li><code>_process_close_market</code> called on Market closure</li> <li><code>_process_cleared_orders()</code> called on ClearedOrders event</li> <li><code>_process_cleared_markets()</code> called on ClearedMarkets event</li> <li><code>_process_end_flumine()</code> called on Flumine termination</li> </ul>"},{"location":"advanced/#streams","title":"Streams","text":""},{"location":"advanced/#market-stream","title":"Market Stream","text":"<p>Flumine handles market streams by taking the parameters provided in the strategies, a strategy will then subscribe to the stream. This means strategies can share streams reducing load or create new if they require different markets or data filter.</p>"},{"location":"advanced/#data-stream","title":"Data Stream","text":"<p>Similar to Market Streams but the raw streaming data is passed back, this reduces ram/CPU and allows recording of the data for future playback, see the example marketrecorder.py</p>"},{"location":"advanced/#historical-stream","title":"Historical Stream","text":"<p>This is created on a per market basis when simulating.</p>"},{"location":"advanced/#order-stream","title":"Order Stream","text":"<p>Subscribes to all orders per account or per <code>config.customer_strategy_ref</code> if provided</p>"},{"location":"advanced/#custom-streams","title":"Custom Streams","text":"<p>Custom streams (aka threads) can be added as per:</p> <pre><code>from flumine.streams.basestream import BaseStream\nfrom flumine.events.events import CustomEvent\n\n\nclass CustomStream(BaseStream):\n    def run(self) -&gt; None:\n        # connect to stream / make API requests etc.\n        response = api_call()\n\n        # callback func\n        def callback(framework, event):\n            for strategy in framework.strategies:\n                strategy.process_my_event(event)\n\n        # push results through using custom event\n        event = CustomEvent(response, callback)\n\n        # put in main queue\n        self.flumine.handler_queue.put(event)\n\n\ncustom_stream = CustomStream(framework, custom=True)\nframework.streams.add_custom_stream(custom_stream)\n</code></pre>"},{"location":"advanced/#error-handling","title":"Error Handling","text":"<p>Flumine will catch all errors that occur in <code>strategy.check_market</code> and <code>strategy.process_market_book</code>, and log either error or critical errors.</p> <p>Tip</p> <p>You can remove this error handling by setting <code>config.raise_errors = True</code></p>"},{"location":"advanced/#logging","title":"Logging","text":"<p>jsonlogger is used to log extra detail, see below for a typical setup:</p> <pre><code>import time\nimport logging\nfrom pythonjsonlogger import jsonlogger\n\nlogger = logging.getLogger()\n\ncustom_format = \"%(asctime) %(levelname) %(message)\"\nlog_handler = logging.StreamHandler()\nformatter = jsonlogger.JsonFormatter(custom_format)\nformatter.converter = time.gmtime\nlog_handler.setFormatter(formatter)\nlogger.addHandler(log_handler)\nlogger.setLevel(logging.INFO)\n</code></pre>"},{"location":"advanced/#simulation","title":"Simulation","text":"<p>flumine patches <code>utcnow</code> when simulating, if you require the 'real datetime' this can be achieved using the following context manager:</p> <pre><code>import datetime\n\nwith framework.simulated_datetime.real_time():\n    print(datetime.datetime.utcnow())\n</code></pre>"},{"location":"advanced/#config","title":"Config","text":""},{"location":"advanced/#simulated","title":"simulated","text":"<p>Updated to True when simulating or paper trading</p>"},{"location":"advanced/#simulated_strategy_isolation","title":"simulated_strategy_isolation","text":"<p>Defaults to True to match orders per strategy, when False prevents double counting of passive liquidity on all orders regardless of strategy.</p>"},{"location":"advanced/#simulation_available_prices","title":"simulation_available_prices","text":"<p>When True will simulate matches against available prices after initial execution, note this will double count liquidity.</p>"},{"location":"advanced/#customer_strategy_ref","title":"customer_strategy_ref","text":"<p>Used as customerStrategyRefs so that only orders created by the running instance are returned.</p>"},{"location":"advanced/#process_id","title":"process_id","text":"<p>OS process id of running application.</p>"},{"location":"advanced/#current_time","title":"current_time","text":"<p>Used for simulation</p>"},{"location":"advanced/#raise_errors","title":"raise_errors","text":"<p>Raises errors on strategy functions, see Error Handling</p>"},{"location":"advanced/#max_execution_workers","title":"max_execution_workers","text":"<p>Max number of workers in execution thread pool</p>"},{"location":"advanced/#async_place_orders","title":"async_place_orders","text":"<p>Place orders sent with place orders flag, prevents waiting for bet delay</p>"},{"location":"advanced/#place_latency","title":"place_latency","text":"<p>Place latency used for simulation / simulation execution</p>"},{"location":"advanced/#cancel_latency","title":"cancel_latency","text":"<p>Cancel latency used for simulation / simulation execution</p>"},{"location":"advanced/#update_latency","title":"update_latency","text":"<p>Update latency used for simulation / simulation execution</p>"},{"location":"advanced/#replace_latency","title":"replace_latency","text":"<p>Replace latency used for simulation / simulation execution</p>"},{"location":"advanced/#order_sep","title":"order_sep","text":"<p>customer_order_ref separator</p>"},{"location":"advanced/#execution_retry_attempts","title":"execution_retry_attempts","text":"<p>Cancel attempts when the OrderStream is not connected</p>"},{"location":"architecture/","title":"Design","text":""},{"location":"architecture/#main-loop","title":"Main loop","text":"<p>Typical to most trading frameworks flumine uses an event driven design with the main thread handling these events through a FIFO queue.</p> <ul> <li>handles all events in order one by one</li> <li>runs in main</li> </ul>"},{"location":"architecture/#uml-diagrams","title":"UML Diagrams","text":""},{"location":"architecture/#packages","title":"Packages","text":""},{"location":"architecture/#classes","title":"Classes","text":""},{"location":"architecture/#events","title":"Events:","text":"<ul> <li><code>MARKET_CATALOGUE</code> Betfair MarketCatalogue object</li> <li><code>MARKET_BOOK</code> Betfair MarketBook object</li> <li><code>RAW_DATA</code> Raw streaming data</li> <li><code>CURRENT_ORDERS</code> Betfair CurrentOrders object</li> <li><code>CLEARED_MARKETS</code> Betfair ClearedMarkets object</li> <li><code>CLEARED_ORDERS</code> Betfair ClearedOrders object</li> </ul> <ul> <li><code>CLOSE_MARKET</code> flumine Close Market update</li> <li><code>STRATEGY_RESET</code> flumine Strategy Reset update</li> <li><code>CUSTOM_EVENT</code> flumine Custom event update</li> <li><code>TERMINATOR</code> flumine End instance update</li> </ul> <p>The above events are handled in the flumine class</p>"},{"location":"architecture/#marketbook-cycle","title":"MarketBook Cycle","text":""},{"location":"architecture/#simulation","title":"Simulation","text":"<p>Simulation is achieved by monkeypatching the datetime function utcnow(), this allows strategies to be simulated as if they were being executed in real time. Functions such as market.seconds_to_start and fillKill.seconds work as per a live execution.</p>"},{"location":"architecture/#streams","title":"Streams","text":"<ul> <li>Single stream (market)</li> <li>As above but 'data' (flumine listener)</li> <li>Order stream</li> <li>Future work:<ul> <li>Custom stream</li> </ul> </li> </ul>"},{"location":"architecture/#strategy","title":"Strategy","text":"<ul> <li>Class based</li> <li>Subscribe to streams</li> <li>Single strategy subscribes to a single market stream</li> </ul>"},{"location":"architecture/#handles","title":"Handles","text":"<ul> <li>Stream reconnect</li> <li>Trading client login/logout</li> <li>Trading client keep alive</li> <li>Future work:<ul> <li>Execution<ul> <li>place/cancel/replace/update</li> <li>controls</li> <li>fillKill</li> </ul> </li> <li>Market Catalogue</li> <li>Polling (scores/raceCard etc)</li> <li>CurrentOrders / ClearedOrders</li> <li>database connection/logging</li> </ul> </li> </ul>"},{"location":"architecture/#notes","title":"notes","text":"<ul> <li>market middleware (analytics/logging)</li> <li>order middleware (controls)</li> <li>paper trading</li> <li>simulation</li> </ul>"},{"location":"clients/","title":"Clients","text":"<p>Flumine is capable of using multiple clients, these can be of the same <code>ExchangeType</code>, a variation depending on use case or your own custom client/wrapper. The default workers handle login/keep-alive/logout and market closure for all clients added to the framework automatically.</p>"},{"location":"clients/#exchangetypes","title":"ExchangeTypes","text":"<ul> <li>BETFAIR: <code>BetfairClient</code></li> <li>SIMULATED: <code>SimulatedClient</code></li> <li>BETCONNECT: <code>BetconnectClient</code></li> </ul>"},{"location":"clients/#strategy-use","title":"Strategy use","text":"<p>To add a client use the <code>add_client</code> this will allow use via <code>framework.clients</code> or <code>strategy.clients</code></p> <pre><code>from flumine import Flumine, clients\n\nframework = Flumine()\n\nclient = clients.BetfairClient(trading)\nframework.add_client(client)\n</code></pre> <p>or when simulating:</p> <pre><code>from flumine import FlumineSimulation, clients\n\nframework = FlumineSimulation()\n\nclient = clients.SimulatedClient(username=\"123\")\nframework.add_client(client)\n</code></pre> <p>To access clients within a strategy use the helper functions:</p> <pre><code>betfair_client = self.clients.get_betfair_default()\n\nclient = self.clients.get_client(ExchangeType.SIMULATED, username=\"123\")\n</code></pre> <p>Tip</p> <p><code>get_default</code> and <code>get_betfair_default</code> will use the first client added via <code>add_client</code> (ordered list)</p> <p>By default a transaction will use <code>clients.get_default()</code> however you can use a particular client:</p> <pre><code>client = self.clients.get_client(ExchangeType.SIMULATED, username=\"123\")\n\nmarket.place_order(order, client=client)\n</code></pre> <p>or using a transaction directly:</p> <pre><code>client = self.clients.get_client(ExchangeType.SIMULATED, username=\"123\")\n\nwith market.transaction(client=client) as t:\n    t.place_order(order)\n</code></pre>"},{"location":"clients/#settings","title":"Settings","text":"<ul> <li><code>transaction_limit</code> (per hour transaction limit)</li> <li><code>interactive_login</code> (betfair interactive login)</li> <li><code>username</code> (defaults to guid)</li> <li><code>order_stream</code> (disable order stream)</li> <li><code>best_price_execution</code> (only configurable when simulating)</li> <li><code>username</code> (defaults to guid)</li> <li><code>min_bet_validation</code> (remove min bet validation)</li> <li><code>paper_trade</code> (simulation engine used)</li> <li><code>market_recording_mode</code> (no order stream / workers)</li> <li><code>simulated_full_match</code> (simulate orders matching 100% on execution)</li> <li><code>execution_cls</code> (configure class used for executing orders)</li> </ul>"},{"location":"controls/","title":"Controls","text":""},{"location":"controls/#trading-controls","title":"Trading Controls","text":"<p>Before placing an order flumine will check the client and trading controls, this allows validation to occur before execution. If an order does not meet any of these validations it is not executed and status is updated to <code>Violation</code>.</p>"},{"location":"controls/#client-controls","title":"Client Controls","text":"<ul> <li><code>MaxTransactionCount</code>: Checks transaction count is not over betfair transaction limit (5000 per hour) </li> </ul>"},{"location":"controls/#trading-controls_1","title":"Trading Controls","text":"<ul> <li><code>OrderValidation</code>: Checks order is valid (size/odds)</li> <li><code>StrategyExposure</code>: Checks order does not invalidate <code>strategy.validate_order</code>, <code>strategy.max_order_exposure</code> or <code>strategy.max_selection_exposure</code></li> </ul>"},{"location":"controls/#skipping-controls","title":"Skipping Controls","text":"<p>Sometimes it is desirable to skip the controls, for example when canceling an open order even if the transaction count has already reached the betfair transaction limit. This can be done by passing <code>force=True</code> when placing or changing an order:</p> <pre><code>market.place_order(order, force=True)\ntransaction.place_order(order, force=True)\n</code></pre> <p>This works for markets and transactions and is supported by the operations <code>place_order</code>, <code>cancel_order</code>, <code>update_order</code>, and <code>replace_order</code>.</p>"},{"location":"controls/#logging-controls","title":"Logging Controls","text":"<p>Custom logging is available using the <code>LoggingControl</code> class, the base class creates debug logs and can be used as follows:</p> <pre><code>from flumine.controls.loggingcontrols import LoggingControl\n\ncontrol = LoggingControl()\n\nframework.add_logging_control(control)\n</code></pre> <p>Tip</p> <p>More than one control can be added, for example a csv logger and db logger.</p>"},{"location":"help/","title":"Help","text":"<p>Please try the following channels for any support:</p> <ul> <li>Betfair Developer Support</li> <li>Slack Group for any help in using the library</li> <li>API Status if things don't seem to be working</li> </ul>"},{"location":"known_issues/","title":"Known Issues and Limitations","text":"<p>This page documents known issues, limitations, and edge cases in flumine that users should be aware of.</p>"},{"location":"known_issues/#simulating-dead-heat-results-in-place-markets","title":"Simulating Dead-Heat Results in PLACE markets","text":""},{"location":"known_issues/#known-limitations","title":"Known Limitations:","text":"<p>To correctly calculate the profit on a PLACE bet when there were more winners than expected, e.g. the market is '3 TBP' but due to a dead heat there are actually 4 winners, requires knowing which 2 selections were in a dead heat.</p> <p>Betfair dead heat rules</p> <p>Unfortunately we do not have this information in the standard market data files, which means that an accurate profit cannot be calculated for these simulated scenarios.</p> <p>As a result, when simulating PLACE markets, Flumine ignores dead-heat results and calculates profit values for each selection as if no dead heat occurred. This means that the total profit for the market could be over- or under-stated if bets were placed on the dead-heat runners.</p>"},{"location":"markets/","title":"Markets","text":""},{"location":"markets/#market","title":"Market","text":"<p>Within markets you have market objects which contains current up to date market data.</p>"},{"location":"markets/#class-variables","title":"Class variables","text":"<ul> <li><code>flumine</code> Framework</li> <li><code>market_id</code> MarketBook id</li> <li><code>closed</code> Closed bool</li> <li><code>date_time_closed</code> Closed datetime</li> <li><code>market_book</code> Latest MarketBook object</li> <li><code>market_catalogue</code> Latest MarketCatalogue object</li> <li><code>context</code> Market context, store market specific context e.g. simulated data store</li> <li><code>blotter</code> Holds all order data and position</li> </ul>"},{"location":"markets/#functions","title":"Functions","text":"<ul> <li><code>place_order(order)</code> Place new order from order object</li> <li><code>cancel_order(order, size_reduction)</code> Cancel order</li> <li><code>update_order(order, new_persistance_type)</code> Update order</li> <li><code>replace_order(order, new_price)</code> Replace order</li> </ul>"},{"location":"markets/#properties","title":"Properties","text":"<ul> <li><code>event</code> Dictionary containing all event related markets (assumes markets have been subscribed)</li> <li><code>event_type_id</code> Betfair event type id (horse racing: 7)</li> <li><code>event_id</code> Market event id (12345)</li> <li><code>market_type</code> Market type ('WIN')</li> <li><code>seconds_to_start</code> Seconds to scheduled market start time (123.45)</li> <li><code>elapsed_seconds_closed</code> Seconds since market was closed (543.21)</li> <li><code>market_start_datetime</code> Market scheduled start time</li> </ul>"},{"location":"markets/#transaction","title":"Transaction","text":"<p>The transaction class is used by default when orders are executed, however it is possible to control the execution behaviour using the transaction class like so:</p> <pre><code>with market.transaction() as t:\n    market.place_order(order)  # executed immediately in separate transaction\n    t.place_order(order)  # executed on transaction __exit__\n\nwith market.transaction() as t:\n    t.place_order(order)\n    ..\n    t.execute()  # above order executed\n    ..\n    t.cancel_order(order)\n    t.place_order(order)  # both executed on transaction __exit__\n</code></pre>"},{"location":"markets/#blotter","title":"Blotter","text":"<p>The blotter is a simple and fast class to hold all orders for a particular market.</p>"},{"location":"markets/#functions_1","title":"Functions","text":"<ul> <li><code>strategy_orders(strategy)</code> Returns all orders related to a strategy</li> <li><code>strategy_selection_orders(strategy, selection_id, handicap)</code> Returns all orders related to a strategy selection</li> <li><code>selection_exposure(strategy, lookup)</code> Returns strategy/selection exposure</li> <li><code>market_exposure(strategy, market_book)</code> Returns strategy/market exposure</li> </ul>"},{"location":"markets/#properties_1","title":"Properties","text":"<ul> <li><code>live_orders</code> List of live orders</li> <li><code>has_live_orders</code> Bool on live orders</li> </ul>"},{"location":"markets/#middleware","title":"Middleware","text":"<p>It is common that you want to carry about analysis on a market before passing through to strategies, similar to Django's middleware design flumine allows middleware to be executed.</p> <p>For example simulation uses simulated middleware in order to calculate order matching.</p> <p>Note</p> <p>Middleware will be executed in the order it is added and before the strategies are processed.</p> <p>Please see below for the example middleware class if you wish to create your own:</p> <pre><code>from flumine.markets.middleware import Middleware\n\nclass CustomMiddleware(Middleware):\n    def __call__(self, market) -&gt; None:\n        pass  # called on each MarketBook update\n\n    def add_market(self, market) -&gt; None:\n        print(\"market {0} added\".format(market.market_id))\n\n    def remove_market(self, market) -&gt; None:\n        print(\"market {0} removed\".format(market.market_id))\n</code></pre> <p>The above middleware can then be added to the framework:</p> <pre><code>framework.add_logging_control(CustomMiddleware())\n</code></pre>"},{"location":"performance/","title":"Performance","text":"<p>Flumine is heavily optimised out of the box to be as quick as possible however there are various ways to improve the performance further with minimal effort.</p>"},{"location":"performance/#simulation","title":"Simulation","text":""},{"location":"performance/#listener-kwargs","title":"Listener Kwargs","text":"<p>This is one of the most powerful options available as the variables are passed down to betfairlightweight limiting the number of updates to process, examples:</p>"},{"location":"performance/#600s-before-scheduled-start-and-no-inplay","title":"600s before scheduled start and no inplay","text":"<pre><code>strategy = ExampleStrategy(\n    market_filter={\n        \"markets\": [\"/tmp/marketdata/1.170212754\"],\n        \"listener_kwargs\": {\"seconds_to_start\": 600, \"inplay\": False},\n    }\n)\n</code></pre>"},{"location":"performance/#inplay-only","title":"inplay only","text":"<pre><code>strategy = ExampleStrategy(\n    market_filter={\n        \"markets\": [\"/tmp/marketdata/1.170212754\"],\n        \"listener_kwargs\": {\"inplay\": True},\n    }\n)\n</code></pre>"},{"location":"performance/#logging","title":"Logging","text":"<p>Logging in python can add a lot of function calls, it is therefore recommended to switch it off once you are comfortable with the outputs from a strategy:</p> <pre><code>logger.setLevel(logging.CRITICAL)\n</code></pre>"},{"location":"performance/#file-location","title":"File location","text":"<p>Flumine uses <code>smart_open</code> to open historical files, so you can read files directly from s3 (<code>s3://http://s3.amazonaws.com/example/1.1234567</code>).</p> <p>This might sound obvious but having the market files stored locally on your machine will allow much quicker processing. A common pattern is to use s3 to store all market files but a local cache for common markets processed.</p>"},{"location":"performance/#betfair-historical-data","title":"Betfair Historical Data","text":"<p>Sometimes a download from the betfair site will include market and event files in the same directory resulting in duplicate processing, flumine will log a warning on this but it is worth checking if you are seeing slow processing times.</p>"},{"location":"performance/#multiprocessing","title":"Multiprocessing","text":"<p>Simulation is CPU bound so can therefore be improved through the use of multiprocessing, threading offers no improvement due to the limitations of the GIL.</p> <p>The multiprocessing example code below will:</p> <ul> <li>run a process per core</li> <li>each <code>run_process</code> will process 8 markets at a time (prevents memory leaks)</li> <li>will wait for all results before completing</li> </ul> <pre><code>import os\nimport math\nimport smart_open\nfrom concurrent import futures\nfrom unittest.mock import patch as mock_patch\nfrom flumine import FlumineSimulation, clients, utils\nfrom strategies.lowestlayer import LowestLayer\n\n\ndef run_process(markets):\n    client = clients.SimulatedClient()\n    framework = FlumineSimulation(client=client)\n    strategy = LowestLayer(\n        market_filter={\"markets\": markets},\n        context={\"stake\": 2},\n    )\n    with mock_patch(\"builtins.open\", smart_open.open):\n        framework.add_strategy(strategy)\n        framework.run()\n\n\nif __name__ == \"__main__\":\n    all_markets = [...]\n    processes = os.cpu_count()\n    markets_per_process = 8  # optimal\n\n    _process_jobs = []\n    with futures.ProcessPoolExecutor(max_workers=processes) as p:\n        chunk = min(\n            markets_per_process, math.ceil(len(all_markets) / processes)\n        )\n        for m in (utils.chunks(all_markets, chunk)):\n            _process_jobs.append(\n                p.submit(\n                    run_process,\n                    markets=m,\n                )\n            )\n        for job in futures.as_completed(_process_jobs):\n            job.result()  # wait for result\n</code></pre> <p>Tip</p> <p>If the code above is failing add logging to the <code>run_process</code> function to find the error or run the strategy in a single process with logging</p>"},{"location":"performance/#strategy","title":"Strategy","text":"<p>The heaviest load on CPU comes from reading the files and processing into py objects before processing through flumine, after this the bottleneck becomes the number of orders that need to be processed. Therefore anything that can be done to limit the number of redundant or control blocked orders will see an improvement.</p>"},{"location":"performance/#cprofile","title":"cprofile","text":"<p>Profiling code is always the best option for finding improvements, <code>cprofilev</code> is a commonly used python library for this:</p> <pre><code>python -m cprofilev examples/simulate.py\n</code></pre>"},{"location":"performance/#middleware","title":"Middleware","text":"<p>If you don't need the simulation middleware remove it from <code>framework._market_middleware</code>, this is useful when processing markets for data collection. This can dramatically improve processing time due to the heavy functions contained in the simulation logic.</p>"},{"location":"performance/#libraries","title":"Libraries","text":"<p>Installing betfairlightweight[speed] will have a big impact on processing speed due to the inclusion of C and Rust libraries for datetime and json decoding.</p>"},{"location":"performance/#live","title":"Live","text":"<p>For improving live trading 'Strategy' and 'cprofile' tips above will help although CPU load tends to be considerably lower compared to simulating.</p>"},{"location":"quickstart/","title":"QuickStart","text":""},{"location":"quickstart/#live","title":"Live","text":"<p>Tip</p> <p>flumine uses <code>betfairlightweight</code> for communicating with the Betfair API, please see docs for how to use/setup before proceeding.</p> <p>First, start by importing flumine/bflw and creating a trading and framework client:</p> <pre><code>import betfairlightweight\nfrom flumine import Flumine, clients\n\ntrading = betfairlightweight.APIClient(\"username\")\nclient = clients.BetfairClient(trading)\n\nframework = Flumine(client=client)\n</code></pre> <p>Note</p> <p>flumine will handle login, logout and keep alive whilst the framework is running using the <code>keep_alive</code> worker.</p> <p>A strategy can now be created by using the BaseStrategy class:</p> <pre><code>from flumine import BaseStrategy\n\n\nclass ExampleStrategy(BaseStrategy):\n    def start(self, flumine):\n        # subscribe to streams\n        print(\"starting strategy 'ExampleStrategy'\")\n\n    def check_market_book(self, market, market_book):\n        # process_market_book only executed if this returns True\n        if market_book.status != \"CLOSED\":\n            return True\n\n    def process_market_book(self, market, market_book):\n        # process marketBook object\n        print(market_book.status)\n</code></pre> <p>This strategy can now be initiated with the market and data filter before being added to the framework:</p> <pre><code>from betfairlightweight.filters import (\n    streaming_market_filter, \n    streaming_market_data_filter,\n)\n\nstrategy = ExampleStrategy(\n    market_filter=streaming_market_filter(\n        event_type_ids=[\"7\"],\n        country_codes=[\"GB\"],\n        market_types=[\"WIN\"],\n    ),\n    market_data_filter=streaming_market_data_filter(fields=[\"EX_ALL_OFFERS\"])\n)\n\nframework.add_strategy(strategy)\n</code></pre> <p>The framework can now be started:</p> <pre><code>framework.run()\n</code></pre>"},{"location":"quickstart/#order-placement","title":"Order placement","text":"<p>Orders can be placed as followed:</p> <pre><code>from flumine.order.trade import Trade\nfrom flumine.order.order import LimitOrder\n\n\nclass ExampleStrategy(BaseStrategy):\n    def process_market_book(self, market, market_book):\n        for runner in market_book.runners:\n            if runner.selection_id == 123:\n                trade = Trade(\n                    market_id=market_book.market_id, \n                    selection_id=runner.selection_id,\n                    handicap=runner.handicap,\n                    strategy=self\n                )\n                order = trade.create_order(\n                    side=\"LAY\", \n                    order_type=LimitOrder(price=1.01, size=2.00)\n                )\n                market.place_order(order)\n</code></pre> <p>This order will be validated through controls, stored in the blotter and sent straight to the execution thread pool for execution. It is also possible to batch orders into transactions as follows:</p> <pre><code>with market.transaction() as t:\n    market.place_order(order)  # executed immediately in separate transaction\n    t.place_order(order)  # executed on transaction __exit__\n\nwith market.transaction() as t:\n    t.place_order(order)\n\n    t.execute()  # above order executed\n\n    t.cancel_order(order)\n    t.place_order(order)  # both executed on transaction __exit__\n</code></pre>"},{"location":"quickstart/#stream-class","title":"Stream class","text":"<p>By default the stream class will be a MarketStream which provides a MarketBook python object, if collecting data this can be changed to a DataStream class however process_raw_data will be called and not process_market_book:</p> <pre><code>from flumine import BaseStrategy\nfrom flumine.streams.datastream import DataStream\n\n\nclass ExampleDataStrategy(BaseStrategy):\n    def process_raw_data(self, publish_time, data):\n        print(publish_time, data)\n\nstrategy = ExampleDataStrategy(\n    market_filter=streaming_market_filter(\n        event_type_ids=[\"7\"],\n        country_codes=[\"GB\"],\n        market_types=[\"WIN\"],\n    ),\n    stream_class=DataStream\n)\n\nflumine.add_strategy(strategy)\n</code></pre> <p>The OrderDataStream class can be used to record order data as per market:</p> <pre><code>from flumine.streams.datastream import OrderDataStream\n\nstrategy = ExampleDataStrategy(\n    market_filter=None,\n    stream_class=OrderDataStream\n)\n\nflumine.add_strategy(strategy)\n</code></pre>"},{"location":"quickstart/#paper-trading","title":"Paper Trading","text":"<p>Flumine can be used to paper trade strategies live using the following code:</p> <pre><code>from flumine import clients\n\nclient = clients.BetfairClient(trading, paper_trade=True)\n</code></pre> <p>Market data will be recieved as per live but any orders will use Simulated execution and Simulated order polling to replicate live trading.</p> <p>Tip</p> <p>This can be handy when testing strategies as the betfair website can be used to validate the market.</p>"},{"location":"quickstart/#simulation","title":"Simulation","text":"<p>Flumine can be used to simulate strategies using the following code:</p> <pre><code>from flumine import FlumineSimulation, clients\n\nclient = clients.SimulatedClient()\nframework = FlumineSimulation(client=client)\n\nstrategy = ExampleStrategy(\n    market_filter={\"markets\": [\"/tmp/marketdata/1.170212754\"]}\n)\nframework.add_strategy(strategy)\n\nframework.run()\n</code></pre> <p>Note the use of market filter to pass the file directories.</p>"},{"location":"quickstart/#listener-kwargs","title":"Listener kwargs","text":"<p>Sometimes a subset of the market lifetime is required, this can be optimised by limiting the number of updates to process resulting in faster simulation:</p> <pre><code>strategy = ExampleStrategy(\n    market_filter={\n        \"markets\": [\"/tmp/marketdata/1.170212754\"],\n        \"listener_kwargs\": {\"inplay\": False, \"seconds_to_start\": 600},\n    }\n)\n</code></pre> <ul> <li>inplay: Filter inplay flag</li> <li>seconds_to_start: Filter market seconds to start</li> <li>max_inplay_seconds: Filter market on max seconds after market turned inplay</li> <li>calculate_market_tv: As per bflw listener arg</li> <li>cumulative_runner_tv: As per bflw listener arg</li> </ul> <p>The extra kwargs above will limit processing to preplay in the final 10 minutes.</p> <p>Tip</p> <p>Multiple strategies and markets can be passed, flumine will pass the MarketBooks to the correct strategy via its subscription.</p>"},{"location":"quickstart/#event-processing","title":"Event Processing","text":"<p>It is also possible to process events with multiple markets such as win/place in racing or all football markets as per live by adding the following flag:</p> <pre><code>strategy = ExampleStrategy(\n    market_filter={\"markets\": [..], \"event_processing\": True}\n)\n</code></pre> <p>To process multiple events in parallel, provide a mapping for event groups in the format <code>{event_id: event_group}</code>. In this example, events with IDs <code>\"123\"</code> and <code>\"456\"</code> are added to execution group <code>\"A\"</code> and will be simulated together.</p> <pre><code>strategy = ExampleStrategy(\n    market_filter={\"markets\": [..], \"event_processing\": True, \"event_groups\": {\"123\": \"A\", \"456\": \"A\"}}\n)\n</code></pre> <p>The <code>Market</code> object contains a helper method for accessing other event linked markets:</p> <pre><code>place_market = market.event[\"PLACE\"]\n</code></pre>"},{"location":"quickstart/#market-filter","title":"Market Filter","text":"<p>When simulating you can filter markets to be processed by using the <code>market_type</code> and <code>country_code</code> filter as per live:</p> <pre><code>strategy = ExampleStrategy(\n    market_filter={\n        \"markets\": [..], \n        \"market_types\": [\"MATCH_ODDS\"], \n        \"country_codes\": [\"GB\"]\n    }\n)\n</code></pre>"},{"location":"quickstart/#simulation_1","title":"Simulation","text":"<p>Simulation uses the <code>SimulatedExecution</code> execution class and tries to accurately simulate matching with the following:</p> <ul> <li>Estimated Place/Cancel/Replace latency delay added (can be changed in the config)</li> <li>Betfair betDelay added based on market state</li> <li>Queue positioning based on liquidity available</li> <li>Order lapse on market version change</li> <li>Order lapse and reduction on runner removal</li> <li>BSP</li> </ul> <p>Limitations #192:</p> <ul> <li>Queue cancellations</li> <li>Double counting of liquidity (active)</li> <li>Currency fluctuations</li> </ul>"},{"location":"sportsdata/","title":"Sports Data","text":"<p>Flumine is able to connect to the sports-data-stream provided by Betfair for live data on cricket and races.</p> <p>Tip</p> <p>Your appKey must be authorised to access the sports-data stream, contact bdp@betfair.com</p>"},{"location":"sportsdata/#cricket-subscription","title":"Cricket Subscription","text":"<p>A cricket subscription can be added via the <code>sports_data_filter</code> on a strategy</p> <pre><code>strategy = ExampleStrategy(\n    market_filter=streaming_market_filter(\n        event_type_ids=[\"4\"], market_types=[\"MATCH_ODDS\"]\n    ),\n    sports_data_filter=[\"cricketSubscription\"],\n)\n</code></pre>"},{"location":"sportsdata/#race-subscription","title":"Race Subscription","text":"<p>A race subscription can be added via the <code>sports_data_filter</code> on a strategy</p> <pre><code>strategy = ExampleStrategy(\n    market_filter=streaming_market_filter(\n        event_type_ids=[\"7\"], market_types=[\"WIN\"]\n    ),\n    sports_data_filter=[\"raceSubscription\"],\n)\n</code></pre>"},{"location":"sportsdata/#strategy","title":"Strategy","text":"<p>Any sports data stream updates will be available in the strategy via the <code>process_sports_data</code> function</p> <pre><code>class ExampleStrategy(BaseStrategy):\n    def process_sports_data(\n        self, market: Market, sports_data: Union[Race, CricketMatch]\n    ) -&gt; None:\n        # called on each update from sports-data-stream\n        print(market, sports_data)\n</code></pre>"},{"location":"sportsdata/#data-recorder","title":"Data Recorder","text":"<p>The example <code>marketrecorder.py</code> can be modified to record race and cricket data by updating the <code>process_raw_data</code> with the matching <code>op</code> and data keys.</p> <ul> <li>marketSubscription <code>mcm</code> and <code>mc</code></li> <li>orderSubscription <code>ocm</code> and <code>oc</code></li> <li>cricketSubscription <code>ccm</code> and <code>cc</code></li> <li>raceSubscription <code>rcm</code> and <code>rc</code></li> </ul> <p>And using the correct stream class:</p>"},{"location":"sportsdata/#cricket-recorder","title":"Cricket Recorder","text":"<pre><code>from flumine.streams.datastream import CricketDataStream\n\nstrategy= MarketRecorder(\n    market_filter=None,\n    stream_class=CricketDataStream,\n    context={\n        \"local_dir\": \"/tmp\",\n        \"force_update\": False,\n        \"remove_file\": True,\n        \"remove_gz_file\": False,\n    },\n)\n</code></pre>"},{"location":"sportsdata/#race-recorder","title":"Race Recorder","text":"<pre><code>from flumine.streams.datastream import RaceDataStream\n\nstrategy= MarketRecorder(\n    market_filter=None,\n    stream_class=RaceDataStream,\n    context={\n        \"local_dir\": \"/tmp\",\n        \"force_update\": False,\n        \"remove_file\": True,\n        \"remove_gz_file\": False,\n    },\n)\n</code></pre>"},{"location":"strategies/","title":"Strategies","text":""},{"location":"strategies/#basestrategy","title":"BaseStrategy","text":"<p>The base strategy class should be used for all strategies and contains the following parameters / functions for order/trade execution.</p>"},{"location":"strategies/#parameters","title":"Parameters","text":"<ul> <li><code>market_filter</code> Streaming market filter or list of filters required</li> <li><code>market_data_filter</code> Streaming market data filter required</li> <li><code>streaming_timeout</code> Streaming timeout, will call snap() on cache every x seconds</li> <li><code>conflate_ms</code> Streaming conflate</li> <li><code>stream_class</code> MarketStream or RawDataStream</li> <li><code>name</code> Strategy name, if None will default to class name</li> <li><code>context</code> Dictionary object where any extra data can be stored here such as triggers</li> <li><code>max_selection_exposure</code> Max exposure per selection (including new order), note this does not handle reduction in exposure due to laying another runner</li> <li><code>max_order_exposure</code> Max exposure per order</li> <li><code>clients</code> flumine.clients</li> <li><code>max_trade_count</code> Max total number of trades per runner</li> <li><code>max_live_trade_count</code> Max live (with executable orders) trades per runner</li> <li><code>multi_order_trades</code> Allow multiple live orders per trade</li> </ul>"},{"location":"strategies/#functions","title":"Functions","text":"<p>The following functions can be overridden dependent on the strategy:</p> <ul> <li><code>add()</code> Function called when strategy is added to framework</li> <li><code>start()</code> Function called when framework starts</li> <li><code>process_new_market()</code> Process Market when it gets added to the framework for the first time</li> <li><code>process_market_catalogue()</code> Process updates to the market catalogue.</li> <li><code>check_market_book()</code> Function called with marketBook, <code>process_market_book</code> is only executed if this returns True</li> <li><code>process_market_book()</code> Processes market book updates, called on every update that is received</li> <li><code>process_raw_data()</code> As per <code>process_market_book</code> but handles raw data</li> <li><code>process_orders()</code> Process list of Order objects for strategy and Market</li> <li><code>process_closed_market()</code> Process Market after closure</li> <li><code>finish()</code> Function called when framework ends</li> </ul>"},{"location":"strategies/#runner-context","title":"Runner Context","text":"<p>Each strategy stores a <code>RunnerContext</code> object which contains the state of a runner based on all and current active trades. This is used by controls to calculate exposure and control the number of live or total trades.</p> <pre><code>runner_context = self.get_runner_context(\n    market.market_id, runner.selection_id, runner.handicap\n)\n\nrunner_context.invested\nrunner_context.trade_count\nrunner_context.live_trade_count\nrunner_context.executable_orders\nrunner_context.placed_elapsed_seconds\nrunner_context.trades\nrunner_context.live_trades\n</code></pre>"},{"location":"trades/","title":"Trades / Orders","text":""},{"location":"trades/#trade","title":"Trade","text":"<p>A trade object is used to handle order execution.</p> <pre><code>from flumine.order.trade import Trade\nfrom flumine.order.ordertype import LimitOrder\n\ntrade = Trade(\n    market_id=\"1.2345678\",\n    selection_id=123456,\n    handicap=1.0,\n    strategy=strategy\n)\ntrade.orders  # []\ntrade.status  # TradeStatus.LIVE\n\norder = trade.create_order(\n    side=\"LAY\",\n    order_type=LimitOrder(price=1.01, size=2.00)\n)\ntrade.orders  # [&lt;BetfairOrder&gt;]\n</code></pre>"},{"location":"trades/#parameters","title":"Parameters","text":"<ul> <li><code>market_id</code> Market Id</li> <li><code>selection_id</code> Selection Id</li> <li><code>handicap</code> Runner handicap</li> <li><code>strategy</code> Strategy object</li> <li><code>notes</code> Trade notes, used to store market / trigger info for later analysis</li> <li><code>place_reset_seconds</code> Seconds to wait since <code>runner_context.reset</code> before allowing another order</li> <li><code>reset_seconds</code> Seconds to wait since <code>runner_context.place</code> before allowing another order</li> </ul>"},{"location":"trades/#custom","title":"custom","text":"<p>You can create your own trade classes and then handle the logic within the <code>strategy.process_orders</code> function.</p>"},{"location":"trades/#order","title":"Order","text":"<p>Order objects store all order data locally allowing trade logic to be applied.</p> <pre><code>from flumine.order.order import BetfairOrder, LimitOrder\n\norder = BetfairOrder(\n    trade=trade,\n    side=\"LAY\",\n    order_type=LimitOrder(price=1.01, size=2.00)\n)\n\norder.status  # OrderStatus.PENDING\norder.executable()\norder.execution_complete()\n</code></pre>"},{"location":"workers/","title":"Workers","text":""},{"location":"workers/#background-workers","title":"Background Workers","text":"<p>Background workers run in their own thread allowing cleanup / cron like workers to run in the background, by default flumine adds the following workers:</p> <ul> <li><code>keep_alive</code>: runs every 1200s (or session_timeout/2) to make sure clients are logged and kept alive</li> <li><code>poll_account_balance</code>: runs every 120s to poll account balance endpoint</li> <li><code>poll_market_catalogue</code>: runs every 60s to poll listMarketCatalogue endpoint</li> <li><code>poll_market_closure</code>: checks for closed markets to get cleared orders at order and market level</li> </ul>"},{"location":"workers/#variables","title":"Variables","text":"<ul> <li><code>flumine</code>: Framework</li> <li><code>function</code>: Function to be called</li> <li><code>interval</code>: Interval in seconds, set to None for single call</li> <li><code>func_args</code>: Function args</li> <li><code>func_kwargs</code>: Function kwargs</li> <li><code>start_delay</code>: Start delay in seconds</li> <li><code>context</code>: Worker context</li> <li><code>name</code>: Worker name</li> </ul>"},{"location":"workers/#custom-workers","title":"Custom Workers","text":"<p>Further workers can be added as per:</p> <pre><code>from flumine.worker import BackgroundWorker\n\ndef func(context: dict, flumine, name=\"\"):\n    print(name)\n\n\nworker = BackgroundWorker(\n    framework, interval=10, function=func, func_args=(\"hello\",)\n)\n\nframework.add_worker(\n    worker\n)\n</code></pre>"}]}